// Colour should be R, G or B; returns an array counting how many pixels of each colour there are.
public byte[] GetHistogram(char Colour = 'R')
        {

            BitmapData bitmapData = internalImage.LockBits(new Rectangle(0, 0, internalImage.Width, internalImage.Height), ImageLockMode.ReadWrite, internalImage.PixelFormat);

            int bytesPerPixel = Bitmap.GetPixelFormatSize(internalImage.PixelFormat) / 8;
            int byteCount = bitmapData.Stride * internalImage.Height;
            byte[] pixels = new byte[byteCount];
byte[] histogram = new byte[256];
            IntPtr ptrFirstPixel = bitmapData.Scan0;
            Marshal.Copy(ptrFirstPixel, pixels, 0, pixels.Length);
            int heightInPixels = bitmapData.Height;
            int widthInBytes = bitmapData.Width * bytesPerPixel;

int ColourOffset = 0;
if (Colour == 'G')
ColourOffset = 1;
else if (Colour == 'R')
ColourOffset = 2;

            for (int y = 0; y < heightInPixels; y++)
            {
                int currentLine = y * bitmapData.Stride;
                for (int x = 0; x < widthInBytes; x = x + bytesPerPixel)
                {
                    Histogram[pixels[currentLine + x + ColourOffset]]++;
                }
            }

            internalImage.UnlockBits(bitmapData);
return Histogram;
        }

// Colour should be R, G or B; returns an array counting how many pixels of each colour there are.
public byte[] GetByteArray(char Colour = 'R')
        {

            BitmapData bitmapData = internalImage.LockBits(new Rectangle(0, 0, internalImage.Width, internalImage.Height), ImageLockMode.ReadWrite, internalImage.PixelFormat);

            int bytesPerPixel = Bitmap.GetPixelFormatSize(internalImage.PixelFormat) / 8;
            int byteCount = bitmapData.Stride * internalImage.Height;
		byte[] pixels = new byte[byteCount];
            byte[] pixelStream = new byte[byteCount/bytesPerPixel];
            IntPtr ptrFirstPixel = bitmapData.Scan0;
            Marshal.Copy(ptrFirstPixel, pixels, 0, pixels.Length);
            int heightInPixels = bitmapData.Height;
            int widthInBytes = bitmapData.Width * bytesPerPixel;

int ColourOffset = 0;
if (Colour == 'G')
ColourOffset = 1;
else if (Colour == 'R')
ColourOffset = 2;
int streamCount = 0;
            for (int y = 0; y < heightInPixels; y++)
            {
                int currentLine = y * bitmapData.Stride;
                for (int x = 0; x < widthInBytes; x = x + bytesPerPixel)
                {
			pixelStream[streamCount] = pixels[currentLine + x + ColourOffset];
                    streamCount++;
                }
            }

            internalImage.UnlockBits(bitmapData);
return pixelStream;
        }

// Colour should be R, G or B; returns an array counting how many pixels of each colour there are. Sets all the pixels of a colour channel to the byte stream sent through
public void SetByteArray(byte[] ColourData, char Colour = 'R')
        {

            BitmapData bitmapData = internalImage.LockBits(new Rectangle(0, 0, internalImage.Width, internalImage.Height), ImageLockMode.ReadWrite, internalImage.PixelFormat);

            int bytesPerPixel = Bitmap.GetPixelFormatSize(internalImage.PixelFormat) / 8;
            int byteCount = bitmapData.Stride * internalImage.Height;
		byte[] pixels = new byte[byteCount];
            IntPtr ptrFirstPixel = bitmapData.Scan0;
            Marshal.Copy(ptrFirstPixel, pixels, 0, pixels.Length);
            int heightInPixels = bitmapData.Height;
            int widthInBytes = bitmapData.Width * bytesPerPixel;

int ColourOffset = 0;
if (Colour == 'G')
ColourOffset = 1;
else if (Colour == 'R')
ColourOffset = 2;
int streamCount = 0;
            for (int y = 0; y < heightInPixels; y++)
            {
                int currentLine = y * bitmapData.Stride;
                for (int x = 0; x < widthInBytes; x = x + bytesPerPixel)
                {
			 pixels[currentLine + x + ColourOffset] = ColourData[streamCount];
                    streamCount++;
                }
            }

            internalImage.UnlockBits(bitmapData);
        }